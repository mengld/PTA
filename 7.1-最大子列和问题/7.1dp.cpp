/*
给定K个整数组成的序列{ N1, N2 , ..., NK  }，“连续子列”被定义为{ Ni , Ni+1 , ..., Nj  }，
其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。
例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

数据1：与样例等价，测试基本正确性；
数据2：102个随机整数；
数据3：103个随机整数；
数据4：104个随机整数；
数据5：105个随机整数；
输入格式:
输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。

输出格式:
在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

输入样例:
6
-2 11 -4 13 -5 -2
输出样例:
20
*/

#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int n;
	cin >> n;
	int* nums = new int[n];
	for (int i = 0; i < n; i++) {
		cin >> nums[i];
	}
	// input end.
	int pre = 0, maxAns = nums[0];
	for (int i = 0; i < n; i++) {
		pre = max(pre + nums[i], nums[i]);
		maxAns = max(maxAns, pre);
	}

	cout << maxAns;

	return 0;
}

/*
方法概述：
依次考察数组中每个元素，定义pre变量，表示以当前变量为右端的一个区间最大值，其取值有两种可能
1. 一个>1的连续区间
2. 单独一个元素（当前元素）
由于问题要求的是连续最大子列，显然对于1，当前pre可定义为：pre = max(pre + nums[i], nums[i])
再定义maxAns，表示pre的最大值
整个子列的结果就是所有pre的最大值，由于pre的维护是滚动的，且循环的最后考察的是数组最后一个元素，因此，maxAns可滚动维护，且循环最后更新的值就是最终结果
时间复杂度O(n)，空间复杂度O(1)
*/
